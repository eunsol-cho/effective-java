# 다 쓴 객체 참조를 해제하라
- GC만 믿고 메모리 걱정 안하다가 메모리 누수(OOM:OutOfMemoryError)를 맛보게 된다.

## 객체 사용후에 참조를 해제 해주자 

### null로 만들어주면 됨?
  - 근데 사실상 객체사용후 일일히 null처리 해주는게 많아서는 안된다.

### 참조를 해제하는 가장 좋은 방법은?
  - 해당 참조를 담은 변수가 유효 범위(scope)를 벗어나게 두는 것
  - 변수를 유효 범위 밖으로 밀어내는 가장 쉬운 방법은 그 변수를 선언할 때의 블록을 벗어나게 하는 것
  - 변수의 범위를 최소한으로 줄이자 (가령 배열의 사이즈를 의미)

### Stack 클래스에서 메모리 누수가 발생한 원인?
- Stack 클래스는 pop 메서드를 통해 객체를 꺼내는데, 이때 pop 메서드는 객체를 꺼내지만, 스택에서는 객체를 제거하지 않는다.
- 스택이 커졌다가 줄어들었을때, 스택에서 꺼내진 객체들은 스택에서 제거되지 않고 남아있게 된다.
- 이는 GC는 알 수 없고, 프로그래머가 알 수 있다. => 이때는 null 처리를 해줘야한다.

### 메모리 누수가 발생하는 또 다른 예
- 자기 메모리를 직접 관리하는 클래스
- 캐시
  - WeakHashMap을 사용하면 캐시에서 엔트리가 사라지게 할 수 있다.
  - 캐시 엔트리의 유효기간을 지정할 수 있다. 그러나, 이를 정확히 알기 어려우며, 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용
  - 쓰지 않는 엔트리를 청해 해줘야함 (ScheduledThreadPoolExecutor를 사용하면 쉽게 구현 가능)
  - LinkedHashMap는 removeEldestEntry 메서드를 통해, 새 엔트리 추가시 기존것을 부순다. (이를 활용해 캐시를 쉽게 생성가능)
- 리스너 혹은 콜백
    - 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, 콜백은 계속 쌓여갈 것이다.
    - 이를 방지하기 위해, 콜백을 약한 참조로 저장하면 GC가 즉시 수거해간다.
    - ex. WeakHashMap을 활용