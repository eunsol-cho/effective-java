# 불필요한 객체 생성을 피해라
- 객체를 재사용 하는것이 경제적이다.

`String s = new String("bikini");` 보다 `String s = "bikini";` 가 좋다.
- 첫번째 방식은 실행시 마다, String 인스턴스를 새로 만든다.
- 두번째 방식은 하나의 String 인스턴스를 사용한다.
  - 가상 머신 안에서 같은 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함

불필요한 객체 생성을 피하는 방식
- 생성자 대신 정적 팩터리 메서드 사용 (아이템1)
  - `Boolean(boolean)` 대신 `Boolean.valueOf(boolean)` 사용 권장
  - 실제로 전자의 방식은 java9에서 deprecated 됨

불변 객체만이 아닌, 가변 객체에서도 사용중 변경 되지 않는다면 재사용 가능하다.

### 생성비용이 비싼 경우도 재사용 권장

```java
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
        + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```
- String.matches 는 정규표현식으로 문자열 형태 확인 하는 가장 쉬운방법
- 성능이 중요할때는 방복해서 사용하기 부적합
- 내부동작방식 : 
  - Pattern 인스턴스를 한 번 쓰고 버림 (GC대상이 됨)
  - Pattern 은 입력받은 정규식에 해당하는 유한 상태 머신??을 만들어 인스턴스 생성 비용이 높다

### 성능 개선

```java
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile(  // Pattern 인스턴스를 클래스 초기화시 생성 (캐싱)
            "^(?=.)M*(C[MD]|D?C{0,3})"
            + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    
    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches(); // 메서드 호출시마다 Pattern 인스턴스 재사용
    }
}
```
- 코드도 보다 명확해짐
- 나아가 isRomanNumeral 메서드 사용시에 Pattern 인스턴스르 초기화 하는 지연 초기화 방식도 있다.(아이템83)
- 하지만, 지연초기화는 성능에 대한 큰 개선보다는 종종 코드의 복잡도만 증가한다.

### 불필요한 객체를 만들지 않는 예 : 어댑터 = 뷰
- 실제 작업은 뒷단 객체에 위임한 인터페이스
- 객체당 하나만 있으면 됨

```java
public interface Map<K, V> {
    // ...
    Set<K> keySet();
    // ...
}
```
- keySet 호출시 마다 Set 인스턴스를 새로 생성하는게 아니라, Map 인스턴스에 대한 뷰를 제공한다.
- Set은 단지 Map 객체에 대한 뷰이며, Map 객체의 변경시 따라 변경 된다. 즉, 새로이 뷰를 생성하지 않는다.

```
🧐 gpt answer


뷰는 원본 데이터에 대한 참조를 나타내며, 이 뷰를 통해 데이터에 접근하거나 변경할 수 있습니다. Map의 keySet() 메서드가 반환하는 Set은 실제로는 원본 Map의 데이터를 참조하는 뷰입니다. 따라서 이 Set을 통해 원소를 제거하면, 원본 Map에서도 해당 키와 관련된 엔트리가 제거됩니다. 반대로, 원본 Map의 내용이 변경되면, 이 뷰인 Set을 통해서도 그 변경 사항을 바로 볼 수 있습니다.

이러한 방식의 장점은 뷰를 사용하면 추가적인 메모리를 사용하지 않고도 Map의 키에 대한 Set을 제공할 수 있습니다. 또한, 뷰를 통한 연산은 원본 데이터에 직접 영향을 주기 때문에 일관성을 유지할 수 있습니다.

요약하면, keySet() 메서드가 반환하는 Set은 별도의 Set 객체를 생성하여 반환하는 것이 아니라, 원본 Map의 키들에 대한 참조, 즉 "뷰"를 제공한다는 의미입니다.
```

### 불필요한 객체를 만드는 예 : auto boxing
- 기본 타입과 박싱된 기본 타입의 구분을 희미하게 해준다. (완전히 없애주는건 아님)
- 이는 의미상의 차이는 적지만, 성능상의 차이를 가져온다. (아이템61)

```java
private static long sum() {
    Long sum = 0L; // Long 객체 생성
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i; // Long 객체 생성 -> 반복문 지날때 마다 인스턴스 생성
    }
    return sum;
}
```
- 총 생성되는 Long 인스턴스의 수는 Integer.MAX_VALUE + 2개
- sum을 Long -> long으로 바꿔주면, 6.3초 -> 0.6초로 성능 개선
- 박싱된 기본 타입보단 기본타입 사용 권장

하지만, 최근들어 JVM의 성능 향상으로, 무작정 객체 생성을 피할 필요는 없다.
- 단순 객체 생성, 파괴정도는 easy
- 프로그램의 명확성, 간결성, 기능을 위해 객체를 만드는 것은 good

단순히 객체 생성을 피하고자 객체 pool을 만들지는 말자?
- DB연결 같은 생성 비용이 큰 작업인 경우는 good
- 일반적으로는 코드를 복잡하게 만들고, 오류 가능성을 높이며, 성능을 떨어뜨린다.
- GC의 성능이 충분히 좋기 때문에 굳이 pool만들지 말고 그때 그때 만들어서 쓰자.

재사용성의 위험성
- 물론 아이템50에서도 나오지만, 방어적 복사가 필요한경우에서 객체의 재사용은 위험할 수 있다.